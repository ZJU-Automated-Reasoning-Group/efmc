"""
Implementation of "Inductive Invariant Generation via Abductive Inference" (OOPSLA'13)

TODO: generated by LLM, to be reviewed

This module implements an algorithm that uses abductive inference to automatically generate
inductive invariants for transition systems. The algorithm works by iteratively strengthening
candidate invariants through abduction until finding an inductive invariant that proves the
desired safety property.

Key concepts:
- Abductive inference: Reasoning that generates hypotheses to explain observations
- Inductive invariant: A formula that is preserved by the transition relation and implies safety
- Counterexample to inductiveness (CTI): A state pair showing where inductiveness fails

The main algorithm:
1. Start with the post-condition as the initial candidate invariant
2. Check if the candidate is inductive
3. If not, use abduction to strengthen it based on counterexamples
4. Repeat until finding an inductive invariant or determining one cannot be found
"""

import logging
from typing import Tuple, Optional, List, Sequence
import time

import z3

from efmc.engines.abduction.abductor.abductor import qe_abduce
from efmc.sts import TransitionSystem
from efmc.utils.verification_utils import VerificationResult, SolverTimeout, check_entailment, \
    are_expressions_equivalent, check_invariant

logger = logging.getLogger(__name__)


class AbductionProver:
    """
    Implements invariant generation using abductive inference.
    """

    def __init__(self, system: TransitionSystem, max_iterations: int = 300):
        """
        Initialize the AbductionProver.

        Args:
            system: The transition system to verify
            max_iterations: Maximum number of strengthening iterations
        """
        self.sts = system
        self.max_iterations = max_iterations

        # Create mappings between current and next-state variables
        self.var_map = list(zip(self.sts.variables, self.sts.prime_variables))
        self.var_map_rev = list(zip(self.sts.prime_variables, self.sts.variables))

        # Store the last counterexample for debugging
        self.last_cti = None

    def check_inductiveness(self, inv: z3.ExprRef) -> Tuple[bool, Optional[z3.ModelRef]]:
        """
        Check if the candidate invariant is inductive.

        An invariant I is inductive if: I ∧ T → I'
        where I' is I with all variables replaced by their primed versions.

        Args:
            inv: Candidate invariant formula

        Returns:
            Tuple containing:
            - Boolean indicating if inv is inductive
            - If not inductive, a counterexample model; otherwise None
        """
        inv_prime = z3.substitute(inv, self.var_map)

        s = z3.Solver()
        s.add(inv, self.sts.trans, z3.Not(inv_prime))
        result = s.check()
            
        return result == z3.unsat, s.model() if result == z3.sat else None

    def strengthen_from_cti(self, inv: z3.ExprRef, cti: z3.ModelRef) -> z3.ExprRef:
        """
        Strengthen the invariant using a counterexample to inductiveness.

        Args:
            inv: Current candidate invariant
            cti: Counterexample model showing non-inductiveness

        Returns:
            Strengthened invariant formula
        """
        # Store the CTI for debugging
        self.last_cti = cti

        # Extract current state constraints from CTI
        pre_state_constraints = []
        for v in self.sts.variables:
            if v in cti:
                pre_state_constraints.append(v == cti[v])

        pre_state = z3.And(*pre_state_constraints) if pre_state_constraints else z3.BoolVal(True)

        # Extract next state constraints and substitute back to current variables
        post_state_constraints = []
        for v in self.sts.prime_variables:
            if v in cti:
                post_state_constraints.append(v == cti[v])

        post_state = z3.And(*post_state_constraints) if post_state_constraints else z3.BoolVal(True)
        post_state_unprime = z3.substitute(post_state, self.var_map_rev)

        # Set up abduction query
        pre_cond = z3.And(inv, pre_state, self.sts.trans)
        post_cond = z3.substitute(inv, self.var_map)  # This is inv'

        try:
            # Perform abduction to find strengthening condition
            strengthening = qe_abduce(pre_cond, post_cond)
            if strengthening is None:
                logger.debug("Abduction failed. Using more targeted approach.")
                # Instead of just excluding the entire pre-state, let's try to generalize
                return self.generalize_strengthening(inv, pre_state, cti)
        except Exception as e:
            logger.warning(f"Abduction error: {e}. Using targeted exclusion.")
            return self.generalize_strengthening(inv, pre_state, cti)

        # Simplify the strengthened invariant
        new_inv = z3.simplify(z3.And(inv, strengthening))
        logger.debug(f"Strengthened invariant: {new_inv}")

        # Verify that the new invariant excludes the CTI
        s = z3.Solver()
        s.add(new_inv, pre_state)
        if s.check() == z3.sat:
            logger.warning("Strengthened invariant does not exclude CTI. Using generalized exclusion.")
            return self.generalize_strengthening(inv, pre_state, cti)

        # Check if we've created a False invariant
        if z3.is_false(new_inv):
            logger.warning("Abduction resulted in False invariant. Using generalized exclusion.")
            return self.generalize_strengthening(inv, pre_state, cti)

        return new_inv

    def generalize_strengthening(self, inv: z3.ExprRef, pre_state: z3.ExprRef, cti: z3.ModelRef) -> z3.ExprRef:
        """
        Apply a more targeted strengthening approach based on generalizing from the CTI.
        
        Args:
            inv: Current candidate invariant
            pre_state: Concrete pre-state from the CTI
            cti: Counterexample model
            
        Returns:
            Strengthened invariant formula
        """
        # Try to find more general constraints from the counterexample
        general_constraints = []
        relevant_vars = self.identify_relevant_variables(inv, cti)
        
        # Create more general constraints based on the CTI values
        for v in relevant_vars:
            if v in cti:
                val = cti[v]
                if z3.is_int_value(val) or z3.is_rational_value(val):
                    # Convert to Python value for comparison
                    val_int = val.as_long() if z3.is_int_value(val) else val.numerator_as_long() / val.denominator_as_long()
                    
                    # For numeric values, create inequality constraints that exclude the CTI
                    if val_int > 0:
                        general_constraints.append(v <= val_int - 1)  # Exclude values >= the CTI value
                    elif val_int < 0:
                        general_constraints.append(v >= val_int + 1)  # Exclude values <= the CTI value
                    else:  # val_int == 0
                        # Try both constraints and pick the one that works best
                        for constraint in [v > 0, v < 0]:
                            test_inv = z3.simplify(z3.And(inv, constraint))
                            if not z3.is_false(test_inv):
                                general_constraints.append(constraint)
                                break
                
                # For boolean values
                elif z3.is_bool(val):
                    if z3.is_true(val):
                        general_constraints.append(z3.Not(v))
                    else:
                        general_constraints.append(v)
                        
        # If we found generalized constraints, try using them
        if general_constraints:
            # Try combining them with OR to be less restrictive
            generalized = z3.Or(*general_constraints)
            new_inv = z3.simplify(z3.And(inv, generalized))
            
            # Check if the constraint excludes the CTI and is not False
            s = z3.Solver()
            s.add(new_inv, pre_state)
            if s.check() == z3.unsat and not z3.is_false(new_inv):
                return new_inv
                
            # Try with AND if OR didn't work
            generalized = z3.And(*general_constraints)
            new_inv = z3.simplify(z3.And(inv, generalized))
            
            # Check again
            s = z3.Solver()
            s.add(new_inv, pre_state)
            if s.check() == z3.unsat and not z3.is_false(new_inv):
                return new_inv
        
        # Fall back to targeted exclusion
        # Instead of just negating the entire state, identify the key variables
        key_vars = self.identify_key_variables(inv, cti)
        if key_vars:
            exclusion_constraints = []
            for v in key_vars:
                if v in cti:
                    exclusion_constraints.append(v != cti[v])
            
            if exclusion_constraints:
                new_inv = z3.simplify(z3.And(inv, z3.Or(*exclusion_constraints)))
                if not z3.is_false(new_inv):
                    return new_inv
        
        # Last resort: just negate a minimal subset of the pre-state
        minimal_constraints = []
        for v in self.sts.variables:
            if v in cti:
                # Try negating just this variable's constraint
                test_constraint = v != cti[v]
                test_inv = z3.simplify(z3.And(inv, test_constraint))
                
                # If this works and doesn't result in False, use it
                if not z3.is_false(test_inv):
                    s = z3.Solver()
                    s.add(test_inv, pre_state)
                    if s.check() == z3.unsat:
                        return test_inv
                
                minimal_constraints.append(test_constraint)
        
        # If we get here, just combine the minimal constraints with OR
        if minimal_constraints:
            new_inv = z3.simplify(z3.And(inv, z3.Or(*minimal_constraints)))
            if not z3.is_false(new_inv):
                return new_inv
        
        # Ultimate fallback: just use the original invariant if all else fails
        # This will force the algorithm to try a different approach
        logger.warning("Could not find suitable strengthening. Returning original invariant.")
        return inv
        
    def identify_relevant_variables(self, inv: z3.ExprRef, cti: z3.ModelRef) -> List[z3.ExprRef]:
        """
        Identify variables that appear in the invariant and are relevant to strengthening.
        
        Args:
            inv: Current invariant
            cti: Counterexample model
            
        Returns:
            List of variables that are relevant for strengthening
        """
        # Extract all variables mentioned in the invariant
        inv_str = str(inv)
        relevant_vars = []
        
        for v in self.sts.variables:
            if str(v) in inv_str:
                relevant_vars.append(v)
                
        return relevant_vars
        
    def identify_key_variables(self, inv: z3.ExprRef, cti: z3.ModelRef) -> List[z3.ExprRef]:
        """
        Identify key variables that are most important for strengthening based on the structure
        of the invariant and the counterexample.
        
        Args:
            inv: Current invariant
            cti: Counterexample model
            
        Returns:
            List of key variables for strengthening
        """
        # Start with all variables in the invariant
        all_vars = self.identify_relevant_variables(inv, cti)
        if not all_vars:
            return self.sts.variables  # If no relevant vars, use all variables
            
        # Try to identify variables that appear in inequalities or other important constraints
        key_vars = []
        inv_str = str(inv)
        
        # Variables appearing in comparisons are likely more important
        comparison_ops = ['<', '>', '<=', '>=', '!=']
        for v in all_vars:
            for op in comparison_ops:
                if f"{v} {op}" in inv_str or f"{op} {v}" in inv_str:
                    key_vars.append(v)
                    break
                    
        # If we didn't find any key variables with comparisons, return all relevant variables
        return key_vars if key_vars else all_vars

    def verify_safety(self, inv: z3.ExprRef) -> VerificationResult:
        """
        Verify that the invariant proves the safety property.

        Checks two conditions:
        1. init → inv        (Initiation)
        2. inv → post        (Safety)

        Note: This does NOT check inductiveness (inv ∧ T → inv').
        Use check_inductiveness() separately for that.

        Args:
            inv: The invariant to verify

        Returns:
            VerificationResult containing the verification outcome and relevant data
        """
        s = z3.Solver()
        # Check initiation
        s.push()
        s.add(self.sts.init, z3.Not(inv))
        if s.check() == z3.sat:
            return VerificationResult(False, None, s.model(), is_unsafe=True)
        s.pop()
        
        # Check safety
        s.push()
        s.add(inv, z3.Not(self.sts.post))
        if s.check() == z3.sat:
            return VerificationResult(False, None, s.model(), is_unsafe=True)
        s.pop()

        return VerificationResult(True, inv)

    def invgen(self, overall_timeout: Optional[int] = None) -> Optional[z3.ExprRef]:
        """
        Generate an inductive invariant using abduction-based refinement.

        Args:
            overall_timeout: Optional timeout for the entire algorithm in seconds.
                             If None, runs until max_iterations is reached.

        Returns:
            An inductive invariant if found, None otherwise

        Raises:
            SolverTimeout: If the solver times out during verification
        """
        start_time = time.time()
        inv = self.sts.post
        past_invariants = set()  # Track previous invariants to detect cycles
        
        logger.info("Starting invariant generation...")
        for iteration in range(self.max_iterations):
            # Check overall timeout
            if overall_timeout is not None and time.time() - start_time > overall_timeout:
                logger.warning(f"Exceeded overall timeout ({overall_timeout} seconds)")
                raise SolverTimeout("Overall algorithm timeout")
            
            logger.debug(f"Iteration {iteration}: Checking current invariant")
            
            # First, simplify the invariant to its most compact form
            inv = z3.simplify(inv)
            
            # If the invariant has been reduced to False, we can't proceed
            if z3.is_false(inv):
                logger.warning("Invariant reduced to False, cannot proceed")
                return None
                
            # Check if the invariant appears in our set of past invariants
            inv_str = str(inv)
            if inv_str in past_invariants:
                logger.warning("Detected cycle in invariant generation")
                return None
                
            past_invariants.add(inv_str)
            
            # Step 1: Check initiation (init => inv)
            s = z3.Solver()
            s.add(self.sts.init, z3.Not(inv))
            if s.check() == z3.sat:
                # Found a counterexample to initiation
                cex = s.model()
                logger.debug(f"Counterexample to initiation: {cex}")
                
                # Extract state constraints from the counterexample
                state_constraints = []
                for v in self.sts.variables:
                    if v in cex:
                        state_constraints.append(v == cex[v])
                
                state = z3.And(*state_constraints) if state_constraints else z3.BoolVal(True)
                
                # We need a more targeted approach to strengthen the invariant
                # Instead of negating the entire state, let's try to identify what part of the invariant
                # is violated by this initial state
                
                # One approach is to attempt to separate the invariant into conjuncts
                # and only strengthen those parts that are violated
                s_check = z3.Solver()
                s_check.add(self.sts.init, state)
                
                # If the invariant is a conjunction, we can strengthen each conjunct individually
                if inv.decl().kind() == z3.Z3_OP_AND:
                    new_conjuncts = []
                    for conjunct in inv.children():
                        s_check.push()
                        s_check.add(z3.Not(conjunct))
                        if s_check.check() == z3.sat:
                            # This conjunct is violated, we need to weaken it
                            # For now, we'll just exclude this specific state for this conjunct
                            new_conjuncts.append(z3.Or(conjunct, z3.Not(state)))
                        else:
                            # This conjunct is valid for the initial state
                            new_conjuncts.append(conjunct)
                        s_check.pop()
                    
                    # Create a new invariant with the strengthened conjuncts
                    if new_conjuncts:
                        inv = z3.And(*new_conjuncts)
                    else:
                        # If we couldn't strengthen any specific conjunct, fall back to the standard approach
                        # But ensure we don't just negate the entire state to False
                        old_inv = inv
                        inv = z3.simplify(z3.And(inv, z3.Not(state)))
                        if z3.is_false(inv):
                            logger.warning("Strengthening resulted in False invariant, trying different approach")
                            inv = old_inv  # Revert to previous invariant
                            return None  # We can't make progress
                else:
                    # If the invariant is not a conjunction, we'll try a different approach
                    # Try to generalize from the counterexample
                    general_constraints = []
                    for v in self.sts.variables:
                        if v in cex:
                            # Check if v appears in the invariant
                            if str(v) in str(inv):
                                # Create a constraint based on the counterexample value
                                val = cex[v]
                                if z3.is_int_value(val) or z3.is_rational_value(val):
                                    # For numeric values, create inequality constraints
                                    if z3.is_true(z3.simplify(val > 0)):
                                        general_constraints.append(v > 0)
                                    elif z3.is_true(z3.simplify(val < 0)):
                                        general_constraints.append(v < 0)
                                    elif z3.is_true(z3.simplify(val == 0)):
                                        general_constraints.append(v != 0)
                    
                    # Add these generalized constraints if we found any
                    if general_constraints:
                        inv = z3.simplify(z3.And(inv, z3.Or(*general_constraints)))
                    else:
                        # Fall back to the standard approach, but be careful not to reduce to False
                        old_inv = inv
                        inv = z3.simplify(z3.And(inv, z3.Not(state)))
                        if z3.is_false(inv):
                            logger.warning("Strengthening resulted in False invariant, trying different approach")
                            inv = old_inv  # Revert to previous invariant
                            return None  # We can't make progress
                
                logger.debug(f"Strengthened invariant after initiation check: {inv}")
                continue
            
            # Step 2: Check if inv => post
            # For most implementations, this should be true since we start with post as our invariant,
            # but it's still good to check in case we weakened the invariant in some way
            if not check_entailment(inv, self.sts.post):
                logger.warning("Current invariant does not imply the post-condition")
                return None
            
            # Step 3: Check inductiveness (inv && trans => inv')
            inductive, cti = self.check_inductiveness(inv)
            if inductive:
                logger.info(f"Found inductive invariant after {iteration} iterations")
                
                # Optionally verify the invariant (for debugging/checking purposes)
                inv_prime = z3.substitute(inv, self.var_map)
                is_valid = check_invariant(self.sts, inv, inv_prime)
                if not is_valid:
                    logger.warning("Final verification of invariant failed")
                    return None
                
                return inv
            
            if cti is None:
                logger.warning("Failed to generate CTI despite non-inductiveness")
                return None
            
            # Step 4: Strengthen the invariant
            logger.debug(f"Strengthening using CTI: {cti}")
            new_inv = self.strengthen_from_cti(inv, cti)
            
            # Ensure we've made progress
            if are_expressions_equivalent(new_inv, inv):
                logger.warning("No progress in strengthening")
                return None
            
            inv = new_inv
        
        logger.warning(f"Exceeded maximum iterations ({self.max_iterations})")
        return None

    def solve(self, timeout: Optional[int] = None) -> VerificationResult:
        """
        Verify the system using abductive invariant generation.

        Args:
            timeout: Optional timeout for the entire algorithm in seconds.

        Returns:
            VerificationResult containing the verification outcome and relevant data
        """
        try:
            inv = self.invgen(overall_timeout=timeout)
            if inv is not None:
                logger.info("System verified safe")
                return VerificationResult(True, inv)
            
            logger.info("Could not find an inductive invariant")
            # last_cti represents a counterexample to inductiveness (CTI) - a state that satisfies the current candidate invariant but whose successor state violates it. It does not necessarily mean there's a concrete counterexample that violates the post-condition.

            # So, if we have a counterexample, we need to determine if it's a real counterexample to safety
            # Or, we may directly return unknown.
            if self.last_cti is not None:
                # Check if the CTI state is reachable from an initial state
                # This is a simplified check - a more thorough approach would involve
                # checking if there's a path from init to the CTI state
                pre_state_constraints = []
                for v in self.sts.variables:
                    if v in self.last_cti:
                        pre_state_constraints.append(v == self.last_cti[v])
                
                pre_state = z3.And(*pre_state_constraints) if pre_state_constraints else z3.BoolVal(True)
                
                # Check if this state violates the post-condition
                s = z3.Solver()
                s.add(pre_state, z3.Not(self.sts.post))
                
                if s.check() == z3.sat:
                    logger.info("Found counterexample to safety")
                    return VerificationResult(False, None, self.last_cti, is_unsafe=True)
                else:
                    logger.info("CTI found but it doesn't violate safety directly")
                    logger.info("Could not determine system safety")
                    return VerificationResult(False, None, self.last_cti, is_unknown=True)
            
            # Otherwise, we don't know if the system is safe or unsafe
            logger.info("Could not determine system safety")
            return VerificationResult(False, None, None, is_unknown=True)
        except SolverTimeout:
            logger.warning("Verification timed out")
            return VerificationResult(False, None, None, is_unknown=True, timed_out=True)
        except Exception as e:
            logger.error(f"Verification error: {e}")
            return VerificationResult(False, None, None, is_unknown=True)
